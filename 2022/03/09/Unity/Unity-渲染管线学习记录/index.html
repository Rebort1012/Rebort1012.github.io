<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Unity-渲染管线学习记录 | Little Perilla</title><meta name="keywords" content="Graphics"><meta name="author" content="Little Perilla"><meta name="copyright" content="Little Perilla"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="DirectX和OpenGL左右手坐标系不同，会有一些差距，得出的矩阵会不一样; OpenGL的投影平面不是视景体的近截面； 顶点(vertexs) 顶点坐标，颜色，法线，纹理坐标（UV），连线索引; 图元(primitives) 几何顶点被组合为图元(点，线段或多边形)，图元装配； 片元(fragments） 图元被分几步转换为片元：图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity-渲染管线学习记录">
<meta property="og:url" content="https://rebort1012.github.io/2022/03/09/Unity/Unity-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Little Perilla">
<meta property="og:description" content="DirectX和OpenGL左右手坐标系不同，会有一些差距，得出的矩阵会不一样; OpenGL的投影平面不是视景体的近截面； 顶点(vertexs) 顶点坐标，颜色，法线，纹理坐标（UV），连线索引; 图元(primitives) 几何顶点被组合为图元(点，线段或多边形)，图元装配； 片元(fragments） 图元被分几步转换为片元：图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg">
<meta property="article:published_time" content="2022-03-09T05:06:34.000Z">
<meta property="article:modified_time" content="2023-02-21T04:33:38.335Z">
<meta property="article:author" content="Little Perilla">
<meta property="article:tag" content="Graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg"><link rel="shortcut icon" href="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041156928.png"><link rel="canonical" href="https://rebort1012.github.io/2022/03/09/Unity/Unity-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity-渲染管线学习记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-21 12:33:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041156929.png" onerror="onerror=null;src='https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Little Perilla</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity-渲染管线学习记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-09T05:06:34.000Z" title="发表于 2022-03-09 13:06:34">2022-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-21T04:33:38.335Z" title="更新于 2023-02-21 12:33:38">2023-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity-渲染管线学习记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>DirectX和OpenGL左右手坐标系不同，会有一些差距，得出的矩阵会不一样;</p>
<p>OpenGL的投影平面不是视景体的近截面；</p>
<p><strong>顶点(vertexs)</strong></p>
<p>顶点坐标，颜色，法线，纹理坐标（UV），连线索引;</p>
<p><strong>图元(primitives)</strong></p>
<p>几何顶点被组合为图元(点，线段或多边形)，图元装配；</p>
<p><strong>片元(fragments）</strong></p>
<p>图元被分几步转换为片元：图元被适当的裁剪，颜色和纹理数据也相应作出必要的调整，相关的坐标被转换为窗口坐标。最后，光栅化将裁剪好的图元转换为片元;</p>
<h2 id="顶点数据（Vertex）"><a href="#顶点数据（Vertex）" class="headerlink" title="顶点数据（Vertex）"></a>顶点数据（Vertex）</h2><p>顶点坐标，颜色，法线，纹理坐标（UV），连线索引（三角形连线顺序-左右手坐标系顺序 不同）；</p>
<p>顶点数据在流水管线中以图元处理：</p>
<p>点(GL_POINTS)、线(GL_LINES)、线条(GL_LINE_STRIP)、三角面(GL_TRIANGLES)；</p>
<p>四边形顶点信息：顶点位置、颜色、UV、四个顶点顺序；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img2020.cnblogs.com/blog/2522637/202112/2522637-20211209141050164-1564977524.png"></p>
<p>索引可以避免共享顶点间数据的多余——<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Vertex_buffer_object">顶点缓存对象(Vertex Buffer Object，VBO)</a>。</p>
<h2 id="顶点着色器（Vertex-Shader）"><a href="#顶点着色器（Vertex-Shader）" class="headerlink" title="顶点着色器（Vertex Shader）"></a>顶点着色器（Vertex Shader）</h2><h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a><strong>矩阵变换</strong></h3><p>通过矩阵变换将世界坐标系下的顶点变换到视口坐标系下显示；</p>
<p>齐次变换：将一个原本是n维的向量用一个n+1维向量来表示（是不是很像投影）;</p>
<p>互为逆矩阵：相乘结果为1;</p>
<p>转置矩阵：行列互换;</p>
<p>正交矩阵：行列向量互相垂直，正交矩阵的逆矩阵就是他的转置矩阵；</p>
<h4 id="模型矩阵到世界矩阵"><a href="#模型矩阵到世界矩阵" class="headerlink" title="模型矩阵到世界矩阵"></a>模型矩阵到世界矩阵</h4><p>Local Coordinate——World Coordinate；</p>
<p>顶点在世界坐标系下可以进行平移（Translation），旋转（Rotation），缩放（Scaling）操作；</p>
<p>按顺序矩阵连乘得到世界矩阵下顶点的坐标；</p>
<p>如果进行缩放操作要考虑法线变换（非均匀缩放-逆矩阵的转置矩阵获得变换法线-切线空间）；</p>
<p><a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_normaltransform.html">OpenGL Normal Vector Transformation</a></p>
<h4 id="世界矩阵到摄像机矩阵"><a href="#世界矩阵到摄像机矩阵" class="headerlink" title="世界矩阵到摄像机矩阵"></a>世界矩阵到摄像机矩阵</h4><p>World Coordinate——View Coordinate；</p>
<p>摄像机矩阵也叫观察矩阵；</p>
<p>摄像机的一些参数：</p>
<p>EyePosition：摄像机位置</p>
<p>FocusPosition：观察目标点（at）</p>
<p>UpDirection：摄像机上方向（不是Y，相对世界）</p>
<p>Near：近截面、Far：远截面</p>
<p>FOV（vertical field of view）：垂直视场角</p>
<p>Aspect Ratio ：屏幕纵横比</p>
<p>以上参数定义了视景体（台体）；</p>
<p>顶点坐标转换到摄像机矩阵逆向思维，理解为将当前顶点平移摄像机当前位置向量的反向量；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211208234540797.png" alt="image-20211208234540797"></p>
<p>摄像机*摄像机变换矩阵肯定会得到一个单位矩阵(坐标系都是单位矩阵)；</p>
<p>摄像机当前的x，y，z轴组成的矩阵和摄像机变换矩阵互为逆矩阵；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211209000201960.png" alt="image-20211209000201960"></p>
<p>通过摄像机参数求得摄像机的xyz轴向量；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211208234204150.png" alt="image-20211208234204150"></p>
<p>由于正交矩阵的逆矩阵就是他的转置矩阵，再添加单位1；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211209000609321.png" alt="image-20211209000609321"></p>
<p>将摄像机变换矩阵和平移矩阵相乘得到摄像机矩阵；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211209000720748.png" alt="image-20211209000720748"></p>
<p>以上为左手坐标系下的摄像机矩阵；</p>
<h4 id="摄像机矩阵到投影矩阵"><a href="#摄像机矩阵到投影矩阵" class="headerlink" title="摄像机矩阵到投影矩阵"></a>摄像机矩阵到投影矩阵</h4><p>View Coordinate——Projection Coordinate；</p>
<p>正交投影和透视投影；</p>
<p>在Dx中近截面就是投影平面；</p>
<p>正交投影每个坐标点只是丢弃了z坐标，就不推导了；</p>
<p>透视投影：通过相似三角形求出视景体内顶点x,y坐标在投影平面的相对位置，保留z坐标；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211209002653905.png" alt="image-20211209002653905"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D3DXMATRIX matProject;</span><br><span class="line"><span class="comment">// 这个函数是设置正交投影矩阵</span></span><br><span class="line"><span class="built_in">D3DXMatrixOrthoLH</span>(&amp;matProject, width, height, Znear, Zfar);</span><br><span class="line">pD3dDevice-&gt;<span class="built_in">SetTransform</span>(D3DTS_PROJECTION, &amp;matProject);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74726302">OpenGL投影矩阵</a></p>
<p>从右到左将以上矩阵连乘获得局部空间到裁剪空间的变换矩阵：</p>
<p>V(clip) &#x3D; M(projection)*M(view)*M(model)*V(local)</p>
<h3 id="着色计算"><a href="#着色计算" class="headerlink" title="着色计算"></a>着色计算</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/2522637-20211209141245288-1154636017.png"></p>
<p>Flat Shading——一个顶点代表三角形颜色，默认索引中第一个顶点颜色；</p>
<p>Gouraud Shading——逐顶点着色，只计算三个顶点关照信息，在光栅化阶段做插值得到各个片段光照信息，缺点：插值导致高光非线性；</p>
<p>Phong Shading——冯氏光照，逐片段着色（像素）法线插值出各个片元的法线信息，在片元着色器中使用法线、UV、位置等计算光照；</p>
<h2 id="曲面细分着色器（Tessellation-Shader）"><a href="#曲面细分着色器（Tessellation-Shader）" class="headerlink" title="曲面细分着色器（Tessellation Shader）"></a>曲面细分着色器（Tessellation Shader）</h2><p>可选阶段；</p>
<p>外壳着色器(Hull Shader)、镶嵌器（Tessellation）、域着色器（Domain Shader）</p>
<p>不创建高模，根据与摄像机距离使用镶嵌器细化模型，添加三角面（LOD）；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/Image%20%5B20%5D.png" alt="Image [20]"></p>
<h2 id="几何着色器（Geometry-Shader）"><a href="#几何着色器（Geometry-Shader）" class="headerlink" title="几何着色器（Geometry Shader）"></a>几何着色器（Geometry Shader）</h2><p>可选阶段；</p>
<p>以图元作为输入数据，可以创建销毁几何图元；</p>
<p>法线可视化——毛发效果；</p>
<p>根据距离摄像机远景动态调整多边形边数实现LOD效果；</p>
<p>公告牌技术（BillBoards）——3D图片替代模型，总是朝向摄像机；</p>
<h2 id="图元组装（Primitive-Assembly）"><a href="#图元组装（Primitive-Assembly）" class="headerlink" title="图元组装（Primitive Assembly）"></a>图元组装（Primitive Assembly）</h2><h3 id="裁剪（Clipping）"><a href="#裁剪（Clipping）" class="headerlink" title="裁剪（Clipping）"></a>裁剪（Clipping）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/Image%20%5B22%5D.png" alt="Image [22]"></p>
<h4 id="线段裁剪"><a href="#线段裁剪" class="headerlink" title="线段裁剪"></a>线段裁剪</h4><p>点面关系，线面关系，通过向量在面上的投影，以及点是否在矩形内；</p>
<p>八方位裁剪法；</p>
<h4 id="三角形裁剪"><a href="#三角形裁剪" class="headerlink" title="三角形裁剪"></a>三角形裁剪</h4><p>平顶三角和平底三角形，判断出界平移顶点；</p>
<p>裁剪算法有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm">Cohen-Sutherland算法</a>、<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm">Liang-Barsky算法</a>和<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm">Sutherland-Hodgman多边形裁剪算法</a></p>
<h3 id="背面剔除（Back-Face-Culling）"><a href="#背面剔除（Back-Face-Culling）" class="headerlink" title="背面剔除（Back-Face Culling）"></a>背面剔除（Back-Face Culling）</h3><p>只和三角形与摄像机的距离有关，不依赖摄像机朝向；</p>
<p>根据三角形顶点顺序，使用左右手坐标系，叉乘求出法向量；</p>
<p>顶点顺时针法向量朝外剔除，逆时针朝内剔除；</p>
<h3 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射 (Screen Mapping)"></a>屏幕映射 (Screen Mapping)</h3><h4 id="透视剔除-Perspective-Division"><a href="#透视剔除-Perspective-Division" class="headerlink" title="透视剔除(Perspective Division)"></a>透视剔除(Perspective Division)</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/2522637-20211209141458405-1288450755.png"></p>
<p>将视景体空间顶点，除以w分量获得标准设备空间，-1到1的立方体空间（CVV-标准视体）；</p>
<p>w分量保留的z坐标的信息，正交投影w分量为1,w分量也就是z值代表了深度信息；</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75686462">OpenGL变换</a>和<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74726302">OpenGL投影矩阵</a>；</p>
<h4 id="视口变换-View-Transform"><a href="#视口变换-View-Transform" class="headerlink" title="视口变换(View Transform)"></a>视口变换(View Transform)</h4><p>通过执行透射除法获得归一化的设备坐标NDC(Normalized Device Coordinate)；</p>
<p>z值在视口变换过程中被映射，OpenGL映射到[-1,1],DirectX[0,1];</p>
<p>NDC坐标映射到窗口坐标要通过平移和缩放过程（相机的宽高比）；</p>
<p>视口矩阵：xy为窗口相对于屏幕的位置；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/image-20211209013022842.png" alt="image-20211209013022842"></p>
<h2 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h2><p>将图元离散为片元的过程；</p>
<p>图元覆盖一个片元（Overlap）——点采样(Point Sampling)，像素中间点在三角形内；</p>
<p>超级采样和多重采样技术，涉及到抗锯齿；</p>
<h3 id="三角形组装（Triangle-Setup）"><a href="#三角形组装（Triangle-Setup）" class="headerlink" title="三角形组装（Triangle Setup）"></a>三角形组装（Triangle Setup）</h3><p>三角形组装会对顶点的输入数据(比如，颜色、法线、纹理坐标)进行插值，得到各个片段对应的数据值，为后面的片元着色器提供片元数据；</p>
<h3 id="三角形遍历（Triangle-Traversal）"><a href="#三角形遍历（Triangle-Traversal）" class="headerlink" title="三角形遍历（Triangle Traversal）"></a>三角形遍历（Triangle Traversal）</h3><p>遍历这些三角图元覆盖了哪些片元的采样点，随后得到该图元所对应的片元；</p>
<p>顶点数据插值获得片元的颜色，法线，UV，深度等信息，用于<a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=3C84D4AF5B16D5356C60D622B62095E3?doi=10.1.1.48.7886&rep=rep1&type=pdf">投射正交插值</a>获得正确的透视颜色纹理等信息；</p>
<h3 id="线段的扫描转化"><a href="#线段的扫描转化" class="headerlink" title="线段的扫描转化"></a>线段的扫描转化</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/74990578"><strong>Bresenham光栅化算法</strong></a></p>
</li>
<li><p><strong>数字微分画线算法DDA (Digital Differential Analyzer)</strong></p>
<p>直线公式，斜率小于1，y增量为整数，大于1，x增量为整数；</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/2522637-20211209141730162-2102593249.png"></p>
<h3 id="多边形填充"><a href="#多边形填充" class="headerlink" title="多边形填充"></a>多边形填充</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongguolei/p/10591724.html"><strong>扫描线填充算法(Scanline Filling)</strong></a></li>
<li><strong>重心计算多边形片元颜色</strong></li>
</ul>
<p>求多边形的几何重心，以重心为顶点，向多边形的各个顶点连线，分割为三角形；</p>
<p>重心颜色：所有三角形顶点颜色的平均值； </p>
<p>计算每个三角形的重心（三个顶点的x，y分别相加除以3）；</p>
<p>将三角形重心坐标和面积关联起来；</p>
<p>sx +&#x3D; curx*curs；</p>
<p>sy +&#x3D; cury*curs；</p>
<p>重心的坐标为：tatal.s总面积</p>
<p>center.x &#x3D; sx&#x2F;total.s;</p>
<p>center.y &#x3D; sy&#x2F;total.s;</p>
<h2 id="片元着色器（Fregment-Shader）"><a href="#片元着色器（Fregment-Shader）" class="headerlink" title="片元着色器（Fregment Shader）"></a>片元着色器（Fregment Shader）</h2><p>色彩混合：颜色的RGB值相加，用于混合所有光照效果</p>
<p>色彩调制：色彩乘法，RGB值分别相乘，相当于给RGB值都乘以一个系数，将颜色变亮或变暗；</p>
<h3 id="Phong光照模型"><a href="#Phong光照模型" class="headerlink" title="Phong光照模型"></a>Phong光照模型</h3><h4 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h4><p>用来模拟全局光照效果；在物体光照信息基础上叠加较小的光照常量；</p>
<h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>光线进入物体内部重新散射出来，看做均匀分部所以和观察者位置无关；只影响亮度；</p>
<ul>
<li><p><strong>兰伯特余弦定律(Lambert Consine Law)</strong></p>
<p>取决表面法线和光线的夹角，夹角越大分量越小，漫反射越小；90度漫反射几乎为0；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/202112090955578.png" alt="image-20211209095512523"></p>
</li>
<li><p><strong>半兰伯特模型(Half Lambert)</strong></p>
<p>v社做半条命时提出，改变物体暗区域的光照信息；</p>
<p>将漫反射系数从[0,1]改为[0.5,1],提高暗部的亮度信息;</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法线和光线的夹角，</span></span><br><span class="line"><span class="built_in">float</span> diflight = dot(s.Normal,lightDir);</span><br><span class="line"><span class="built_in">float</span> hLambert = difLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="镜面反射高光"><a href="#镜面反射高光" class="headerlink" title="镜面反射高光"></a>镜面反射高光</h4><p>和观察者的位置有关，不同角度观察结果不同；</p>
<ul>
<li><strong>Phong光照模型</strong></li>
</ul>
<p>光线反射向量和观察向量的夹角；</p>
<p>高光指数：e</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/202112091022764.png" alt="image-20211209102210717"></p>
<p>在夹角大于90度的情况，会造成高光丢失现象，光线会不连续，有明显的明暗分界线；</p>
<ul>
<li><strong>Blinn-Phong光照模型</strong></li>
</ul>
<p>光线向量和观察向量的中间位置（半角向量）和法线的夹角；</p>
<p>在任何角度观察，夹角都不会大于90度；不会出现高光不连续现象；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/202112091010490.png" alt="img"></p>
<ul>
<li><p><strong>材质</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Material</span><br><span class="line">&#123;</span><br><span class="line">	vector3 ambient;	<span class="comment">//环境光</span></span><br><span class="line">	vector3 diffuse;	<span class="comment">//漫反射</span></span><br><span class="line">	vector3 Specular;	<span class="comment">//镜面反射 </span></span><br><span class="line">	vector3 emissive;	<span class="comment">//自发光</span></span><br><span class="line">	<span class="built_in">float</span> e;			<span class="comment">//镜面反射系数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>物体最终颜色 &#x3D; 环境光结果*环境光反射系数 + 漫反射结果*漫反射系数+镜面反射结果（计算了高光指数）*镜面反射系数+材质自发光颜色*自放光系数；</p>
</li>
</ul>
<h3 id="纹理贴图-Textures"><a href="#纹理贴图-Textures" class="headerlink" title="纹理贴图 (Textures)"></a>纹理贴图 (Textures)</h3><p>纹理映射，将图像信息映射到三角形网格；</p>
<p>凹凸贴图(bump mapping)、法线贴图(normal mapping)、高度纹理(height mapping)、视差贴图(parallax mapping)、位移贴图(displacement mapping)、立方体贴图(cubemap)、阴影贴图(shadowmap)；</p>
<ul>
<li><strong>UV坐标的寻址方式</strong></li>
</ul>
<p>归一化到[0,1]之间，像素大小为2的次方，方便计算处理；</p>
<p>寻址方式也叫平铺方式：重复寻址(repeat)、边缘钳制寻址(clamp)和镜像寻址(mirror)；</p>
<p>uv超出0-1，该如何寻址（就是图片的平铺，边缘像素扩展，镜像）；</p>
<ul>
<li><strong>纹理采样方式</strong></li>
</ul>
<p>纹理像素和图元像素不是一一对应，要用到纹理的滤波方式；</p>
<p>点过滤(point)、线性过滤(linear)、最近领点过滤(nearest neighbor point)和双线性过滤(bilinear)，Unity的Trilinear滤波的技术；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/202112091051232.png" alt="Image [58]"></p>
<ul>
<li><strong>法线贴图 (Normal Mapping)</strong></li>
</ul>
<p>物体空间(object space)和切线空间(tangent space)</p>
<p>根据物体空间计算的法线，在物体旋转移动后回得到错误的光照信息；</p>
<p>**<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuchenwuhen/article/details/71055602">切线空间</a>**：相对于顶点坐标存储计算；</p>
<p>顶点本身法线为N轴，模型给定定义一条和该顶点相切的切线T轴，N和T叉乘得到B轴；</p>
<p>法线(N)、切线(T)和副切线(B) ，三个轴组成切线空间；</p>
<p>法线贴图就是在切线空间中记录了法线扰动的方向；</p>
<p>以顶点法线N为z轴坐标系，扰动后的法线z轴也总是朝向（0，0，1），所以得得到法线贴图总是淡蓝色（RGB）；</p>
<p>法线纹理最终值需要做个映射,由于维度向量取值[-1,1],纹理通道范围在[0,1],最终记录结果为：<strong>（normal+1）&#x2F;2;</strong></p>
<p><strong>切线空间坐标系到世界坐标系的转换矩阵</strong></p>
<p>物体移动旋转时，法线乘以这个矩阵就可以得到改变后的法线；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/202112091117810.png" alt="Image [61]"></p>
<p>因为z总是朝向（0,0,1）纹理就可以直接记录xy——<a target="_blank" rel="noopener" href="https://developer.download.nvidia.cn/whitepapers/2008/real-time-normal-map-dxt-compression.pdf">纹理压缩</a>：DXT1,DXT5;</p>
<h3 id="锯齿和抗锯齿-Aliasing-and-Anti-aliasing"><a href="#锯齿和抗锯齿-Aliasing-and-Anti-aliasing" class="headerlink" title="锯齿和抗锯齿 (Aliasing and Anti-aliasing)"></a>锯齿和抗锯齿 (Aliasing and Anti-aliasing)</h3><ul>
<li><p><strong>超级采样抗锯齿 (Super-Sampling Anti-aliasing——SSAA)</strong></p>
<p>将原图分辨率放大一倍，再采样；光栅化和片元着色都是原来的4倍，渲染缓存也是4倍；</p>
</li>
<li><p><strong>多重采样抗锯齿 (Multi-Sampling Anti-aliasing——MSAA)</strong></p>
<p>每个片元有多个采样点，计算采样点的覆盖率（Coverage），光栅化阶段计算采样点覆盖率，在片元着色器计算颜色值后乘以这个覆盖率；</p>
<p>MSAA和延迟渲染（deferred render）不兼容(延迟渲染需要Geometry 和Lighting两个Pass，lighting阶段无法通过GBuffer获得片元覆盖率)；</p>
</li>
</ul>
<h3 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 (Shadows)"></a>阴影 (Shadows)</h3><p>光照烘焙获得Shadowmap；先光照烘焙获得深度信息，再通过阴影贴图判断那些片元落在阴影中；</p>
<p>Shadowmap的精度会导致阴影粉刺，需要便宜深度来消除粉刺现象；</p>
<p>阴影锯齿通过百分比渐进过滤（PCF）实现软化阴影（softshadow）；</p>
<h2 id="测试和混合-Tests-amp-Blending"><a href="#测试和混合-Tests-amp-Blending" class="headerlink" title="测试和混合(Tests &amp; Blending)"></a>测试和混合(Tests &amp; Blending)</h2><h4 id="裁切测试-Scissor-Test"><a href="#裁切测试-Scissor-Test" class="headerlink" title="裁切测试 (Scissor Test)"></a>裁切测试 (Scissor Test)</h4><p>裁切测试可以避免当视口比屏幕窗口小时造成的渲染浪费问题；一般默认不开启，</p>
<h4 id="Alpha测试-Alpha-Test"><a href="#Alpha测试-Alpha-Test" class="headerlink" title="Alpha测试 (Alpha Test)"></a>Alpha测试 (Alpha Test)</h4><pre><code>片段着色器中丢弃alpha值小于0.1的片段；
</code></pre>
<ul>
<li><p><strong>Early-Z Culling</strong></p>
<p>硬件厂商用来加速渲染的手段；在片元着色之前提出被遮挡的片元；</p>
<p>但是生效要求只能通过光栅化插值得到深度，不能再片元着色器阶段去修改深度缓冲；</p>
</li>
</ul>
<h4 id="模板测试-Stencil-Test"><a href="#模板测试-Stencil-Test" class="headerlink" title="模板测试 (Stencil Test)"></a>模板测试 (Stencil Test)</h4><p>模板测试有一个对应的缓存, 即模板缓存(Stencil Buffer), 用于记录所有<strong>像素</strong>的模板值, 默认值为0；</p>
<p>片元携带的参考值和模板缓存中的值比较，满足比较函数，调用操作函数更新模板值；</p>
<ul>
<li><p><strong>模板值</strong>: 模板缓存中已经存在的值</p>
</li>
<li><p><strong>参考值</strong>: 在渲染该物体前, 由程序设置的指定值</p>
</li>
<li><p><strong>比较函数</strong>: 决定如何将两个值作比较的函数</p>
</li>
<li><p><strong>操作函数</strong>: 定义通过或者不通过测试后对模板值的更新操作</p>
</li>
</ul>
<p> <strong>Unity中模板测试</strong>不可编程，可配置管线阶段；</p>
  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Stencil</span><br><span class="line">&#123;</span><br><span class="line">    Ref refValue		<span class="comment">//参考值</span></span><br><span class="line">    Comp always			<span class="comment">//比较函数	</span></span><br><span class="line">    Pass keep			<span class="comment">//模板测试和深度测试都通过后的操作</span></span><br><span class="line">    Fail keep			<span class="comment">//模板测试和深度测试都未通过后的操作</span></span><br><span class="line">    ZFail keep			<span class="comment">//模板测试通过而深度测试未通过后的操作</span></span><br><span class="line">    WriteMask <span class="number">255</span>		<span class="comment">//使用参考值更新模板值之前, 在模板值与掩码按位与之后再更新		255代表不做处理</span></span><br><span class="line">    ReadMask <span class="number">255</span>		<span class="comment">//读取模板值后, 将其与掩码按位与之后再与参考值作比较		  255代表不做处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UnityEngine.Rendering.CompareFunction比较函数枚举</span></span><br><span class="line"><span class="comment">0(Disabled): 关闭模板测试, 等同于全部通过测试, 经过测试发现不是真的关闭.</span></span><br><span class="line"><span class="comment">1(Never): 全部不能通过测试</span></span><br><span class="line"><span class="comment">2(Less): 待比较的值小于缓存中的值时通过测试</span></span><br><span class="line"><span class="comment">3(Equal): 待比较的值等于缓存中的值时通过测试</span></span><br><span class="line"><span class="comment">4(LessEqual): 待比较的值小于等于缓存中的值时通过测试</span></span><br><span class="line"><span class="comment">5(Greater): 待比较的值大于缓存中的值时通过测试</span></span><br><span class="line"><span class="comment">6(NotEqual): 待比较的值不等于缓存中的值时通过测试</span></span><br><span class="line"><span class="comment">7(GreaterEqual): 待比较的值大于等于缓存中的值时通过测试</span></span><br><span class="line"><span class="comment">8(Always): 全部通过测试, 默认值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">UnityEngine.Rendering.StencilOp操作函数枚举</span></span><br><span class="line"><span class="comment">0(Keep): 保持模板缓存中的值不变</span></span><br><span class="line"><span class="comment">1(Zero): 将模板缓存中的值置为0</span></span><br><span class="line"><span class="comment">2(Replace): 使用参考值替换模板缓存中的值</span></span><br><span class="line"><span class="comment">3(IncrementSaturate): 使模板缓冲区值增大, 最大限制为可表示的最大无符号值</span></span><br><span class="line"><span class="comment">4(DecrementSaturate): 使模板缓冲区值减小, 最小限制为0</span></span><br><span class="line"><span class="comment">5(Invert): 对模板缓冲区值按位求反</span></span><br><span class="line"><span class="comment">6(IncrementWrap): 与IncrementSaturate类似, 只是达到最大后继续增大将重新设置为 0</span></span><br><span class="line"><span class="comment">7(DecrementWrap): 与DecrementSaturate类似, 只是达到最小后继续减小将重新设置为可表示的最大无符号值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="深度测试-Depth-Test"><a href="#深度测试-Depth-Test" class="headerlink" title="深度测试 (Depth Test)"></a>深度测试 (Depth Test)</h4><p>比较当前片段的深度值是否比深度缓冲中预设的值小(默认比较方式)，如果是更新深度缓冲和颜色缓冲；否则丢弃片段不更新缓冲区的值；</p>
<p>Early-Z Culling也是利用Z-Buffer的技术来进行深度测试的，只不过该测试是在片段着色器之前进行；</p>
<p>深度测试是可配置的阶段——<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ljx12138/p/5341381.html">ZTest和ZWrite</a>；</p>
<ul>
<li><strong>Z-Fighting</strong></li>
</ul>
<p>深度缓冲精度不够，深度值相近的片元会造成重叠模糊问题：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/Rebort1012/picgo/main/202112091255817.png" alt="Image [83]"></p>
<p>解决：物体不要靠太近；使用高精度的深度缓冲；</p>
<ul>
<li><strong>隐藏面消除 (Hidden Surface Removal, HSR)</strong></li>
</ul>
<p>前面的图元组装裁剪，背面拣选，和Z-Buff都属于HSR，裁剪针对图元，Z-Buffer针对像素点；目的都是为了减少到达片元着色器的片元个数，提高渲染性能；</p>
<p><strong>视椎体剔除 (Viewing-Frustum Culling)</strong></p>
<p>利用物体包围盒来做交差检测，常见的包围盒<a target="_blank" rel="noopener" href="http://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Bounding_Boxes.html">有轴对齐包围盒(AABB)和有向包围盒(OBB)</a>两种；</p>
<p>需要是由高效数据结构来提升碰撞检测的效率——八叉树(OcTree)、二分空间划分(Binary Space Partitioning)、四叉树(Quad Tree)、场景图(Scene Graphs)、kd树(K-Dimensional Tree)和层次包围(Bounding Volume Hierarchies)；</p>
<p><strong>计算：</strong></p>
<p>点法式判断三维空间点和面的关系，裁剪掉不在视景体内的包围盒顶点；</p>
<p>求视景体六个面：</p>
<p>通过投影矩阵，求出投影和摄像机的逆矩阵，反向求出视景体对应面；</p>
<p>求逆矩阵——行列式，代数余子式，伴随矩阵，行列式的值，有固定公式；</p>
<p><strong>近截面裁剪：</strong></p>
<p>三角形和面的关系，用向量表示三角形和面；两条共起点的向量可以表示三角形；分解成线和面的关系；</p>
<p>三角形和近截面的关系：</p>
<p>1个角在视景体内——偏移另外两个顶点到视景体平面上；</p>
<p>2个角在视景体内——三角形拆分为2个三角形，注意三角形顶点连线顺序；</p>
<p><strong>入口剔除 (Portal Culling)</strong></p>
<p>将室内的门或者窗户看做视椎体来进行裁剪；实现”笼中窥梦”的效果；</p>
<p><strong>遮挡剔除 (Occlusion Culling)</strong></p>
<p>通过离线烘焙的犯法来预先计算出潜在可视集合(Potentially Visible Set，PVS)；</p>
<p>PVS记录了每个地形块(Tiles)可能看到的物体的集合，用于运行时查找计算；</p>
<p>场景划分为小地形块，每个块上随机取N个采样点；</p>
<p>从采样点发射射线获取场景中和射线相交的物体，记录物体ID;</p>
<p>根据摄像机位置，使用采样点几率的物体id列表进行渲染；</p>
<p>采样精度和烘焙效率问题；</p>
<h4 id="Alpha混合-Alpha-Blending"><a href="#Alpha混合-Alpha-Blending" class="headerlink" title="Alpha混合 (Alpha Blending)"></a>Alpha混合 (Alpha Blending)</h4><p>经过前面所有的测试才能进入Alpha混合阶段，一个测试过不了都到不了Alpha混合；</p>
<p>Alpha混合实现物体半透明效果，渲染顺利非常重要，可能需要手动改Queue（<a target="_blank" rel="noopener" href="https://blog.csdn.net/puppet_master/article/details/53900568">渲染队列</a>）的值；</p>
<ul>
<li><strong>渲染顺序：</strong></li>
</ul>
<p>先渲染不透明物体，从前往后渲染；——不透明物体渲染前先进行深度检测，先后近的物体，远处物体通不过深度检测，就不用进行深度写入操作；</p>
<p>再渲染半透明物体，从后往前渲染；——半透明物体渲染需要知道前一层的颜色信息进行混合，先渲染远处物体，在画近处物体时可以通过颜色缓存获取前一层颜色信息；</p>
<p><strong>画家算法</strong>：先画物体会被后画物体覆盖；</p>
<p>Unity ShaderLab中渲染队列设置；</p>
<p>Queue 其他预定义的值为：Background &#x3D; 1000 , AlphaTest &#x3D; 2450，Overlay &#x3D; 4000。默认值是Geometry &#x3D;2000；</p>
<p>ShaderLab默认开启深度测试和深度写入；</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将本 Shader 计算出的颜色值(源颜色值，即蓝色) * 源Alpha值(0.6) + 目标颜色值(可以理解为背景色) * (1-0.6)</span></span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"><span class="comment">// Transparent (透明) = 3000，值越小越先渲染，而后渲染( Queue 值大)的物体会覆盖先渲染的物体    </span></span><br><span class="line">Tags &#123;<span class="string">&quot;Queue&quot;</span> = <span class="string">&quot;Transparent&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">ZTest LEqual 	       <span class="comment">//小于等于</span></span><br><span class="line">ZWrite On 		<span class="comment">//打开</span></span><br><span class="line"><span class="comment">//ZTest 可取值为：Greater , GEqual , Less , LEqual , Equal , NotEqual , Always , Never , Off，默认是 LEqual，ZTest Off 等同于 ZTest Always</span></span><br><span class="line"><span class="comment">//ZWrite 可取值为：On , Off，默认是 On</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>顺序无关半透明算法（Order-independent transparency，OIT）</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/127399447">深度剥离(Depth Peeling)</a></p>
<p>双向剥离(Dual Depth Peeling)——两个方向剥离，一个从前往后，一个从后往前，两个方向效率提高；</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://rebort1012.github.io">Little Perilla</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://rebort1012.github.io/2022/03/09/Unity/Unity-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">https://rebort1012.github.io/2022/03/09/Unity/Unity-渲染管线学习记录/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://rebort1012.github.io" target="_blank">Little Perilla</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Graphics/">Graphics</a></div><div class="post_share"><div class="social-share" data-image="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/09/Unity/Unity-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E6%B5%81%E7%A8%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" onerror="onerror=null;src='https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity-渲染管线流程</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/09/Unity/Unity-%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" onerror="onerror=null;src='https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity-技能系统</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/28/Unity/Unity-2D%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B(%E6%8F%8F%E8%BE%B9%E6%95%88%E6%9E%9C)/" title="Unity-2D边缘检测(描边效果)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-28</div><div class="title">Unity-2D边缘检测(描边效果)</div></div></a></div><div><a href="/2022/05/28/Unity/Unity-ShaderLab%E5%AE%9E%E7%8E%B0%E5%85%89%E7%85%A7%E7%B3%BB%E7%BB%9F/" title="Unity-ShaderLab实现光照系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-28</div><div class="title">Unity-ShaderLab实现光照系统</div></div></a></div><div><a href="/2022/03/09/Unity/Unity-ShaderLab%E5%AE%9E%E7%8E%B0%E7%8E%BB%E7%92%83%E5%92%8C%E9%95%9C%E5%AD%90%E6%95%88%E6%9E%9C/" title="Unity-ShaderLab实现玻璃和镜子效果"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="title">Unity-ShaderLab实现玻璃和镜子效果</div></div></a></div><div><a href="/2022/03/09/Unity/Unity-ShaderLab%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB/" title="Unity-ShaderLab纹理动画"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="title">Unity-ShaderLab纹理动画</div></div></a></div><div><a href="/2022/03/09/Unity/Unity-Texture+PBR%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/" title="Unity-Texture+PBR两种工作流程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-09</div><div class="title">Unity-Texture+PBR两种工作流程</div></div></a></div><div><a href="/2022/07/16/Unity/Unity-%E5%83%8F%E7%B4%A0%E6%99%B6%E6%A0%BC%E5%8C%96%E6%B6%88%E8%9E%8D/" title="Unity-2D像素晶格化消融"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-16</div><div class="title">Unity-2D像素晶格化消融</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041156929.png" onerror="this.onerror=null;this.src='https://picsheet.oss-cn-hangzhou.aliyuncs.com/202208041117631.jpg'" alt="avatar"/></div><div class="author-info__name">Little Perilla</div><div class="author-info__description">技术分享，学习记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Rebort1012"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Rebort1012" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:871899125@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">不定期摸鱼，躺平</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE%EF%BC%88Vertex%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">顶点数据（Vertex）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Vertex-Shader%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">顶点着色器（Vertex Shader）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">矩阵变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E5%88%B0%E4%B8%96%E7%95%8C%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">模型矩阵到世界矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E7%9F%A9%E9%98%B5%E5%88%B0%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.2.</span> <span class="toc-text">世界矩阵到摄像机矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%91%84%E5%83%8F%E6%9C%BA%E7%9F%A9%E9%98%B5%E5%88%B0%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5"><span class="toc-number">2.1.3.</span> <span class="toc-text">摄像机矩阵到投影矩阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E8%AE%A1%E7%AE%97"><span class="toc-number">2.2.</span> <span class="toc-text">着色计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Tessellation-Shader%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">曲面细分着色器（Tessellation Shader）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Geometry-Shader%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">几何着色器（Geometry Shader）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%85%83%E7%BB%84%E8%A3%85%EF%BC%88Primitive-Assembly%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">图元组装（Primitive Assembly）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%EF%BC%88Clipping%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">裁剪（Clipping）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E8%A3%81%E5%89%AA"><span class="toc-number">5.1.1.</span> <span class="toc-text">线段裁剪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%A3%81%E5%89%AA"><span class="toc-number">5.1.2.</span> <span class="toc-text">三角形裁剪</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4%EF%BC%88Back-Face-Culling%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">背面剔除（Back-Face Culling）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84-Screen-Mapping"><span class="toc-number">5.3.</span> <span class="toc-text">屏幕映射 (Screen Mapping)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E8%A7%86%E5%89%94%E9%99%A4-Perspective-Division"><span class="toc-number">5.3.1.</span> <span class="toc-text">透视剔除(Perspective Division)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3%E5%8F%98%E6%8D%A2-View-Transform"><span class="toc-number">5.3.2.</span> <span class="toc-text">视口变换(View Transform)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%EF%BC%88Rasterization%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">光栅化（Rasterization）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E7%BB%84%E8%A3%85%EF%BC%88Triangle-Setup%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">三角形组装（Triangle Setup）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86%EF%BC%88Triangle-Traversal%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">三角形遍历（Triangle Traversal）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E7%9A%84%E6%89%AB%E6%8F%8F%E8%BD%AC%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">线段的扫描转化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%A1%AB%E5%85%85"><span class="toc-number">6.4.</span> <span class="toc-text">多边形填充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Fregment-Shader%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">片元着色器（Fregment Shader）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Phong%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">Phong光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%85%89"><span class="toc-number">7.1.1.</span> <span class="toc-text">环境光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-number">7.1.2.</span> <span class="toc-text">漫反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E9%AB%98%E5%85%89"><span class="toc-number">7.1.3.</span> <span class="toc-text">镜面反射高光</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E8%B4%B4%E5%9B%BE-Textures"><span class="toc-number">7.2.</span> <span class="toc-text">纹理贴图 (Textures)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AF%E9%BD%BF%E5%92%8C%E6%8A%97%E9%94%AF%E9%BD%BF-Aliasing-and-Anti-aliasing"><span class="toc-number">7.3.</span> <span class="toc-text">锯齿和抗锯齿 (Aliasing and Anti-aliasing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1-Shadows"><span class="toc-number">7.4.</span> <span class="toc-text">阴影 (Shadows)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%92%8C%E6%B7%B7%E5%90%88-Tests-amp-Blending"><span class="toc-number">8.</span> <span class="toc-text">测试和混合(Tests &amp; Blending)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%81%E5%88%87%E6%B5%8B%E8%AF%95-Scissor-Test"><span class="toc-number">8.0.1.</span> <span class="toc-text">裁切测试 (Scissor Test)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Alpha%E6%B5%8B%E8%AF%95-Alpha-Test"><span class="toc-number">8.0.2.</span> <span class="toc-text">Alpha测试 (Alpha Test)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95-Stencil-Test"><span class="toc-number">8.0.3.</span> <span class="toc-text">模板测试 (Stencil Test)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95-Depth-Test"><span class="toc-number">8.0.4.</span> <span class="toc-text">深度测试 (Depth Test)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Alpha%E6%B7%B7%E5%90%88-Alpha-Blending"><span class="toc-number">8.0.5.</span> <span class="toc-text">Alpha混合 (Alpha Blending)</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #121212"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By Little Perilla</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Life is too short for so much sorrow,but love is actually all around.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="little,love,sweet,perilla,skylar,louise" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>